"""
Docstring for particles
"""
from __future__ import annotations
from math import sqrt
from random import random, choice

class Particle:
    #NOTE might add colors with colorama or termcolor in the future, excluding the need for unique chars
    def __init__(self, char: str, particles: list[Particle]): # in regular PL simulators you would use colors, since this is ASCII, we use char
        self.char = char
        self.speed = 0
        self.dirX = 0 # between -1 and 1
        self.dirY = 0 # between -1 and 1
        # particles is a list of all particle objects
        self.particles = particles
    

    def update_particle_list(self, particles: list[Particle]) -> None:
        """
        Docstring for update_particle_list
        
        :param self: Description
        :param particles: Description
        :type particles: list[particle]

        updates the list of particles based on the state of
        the global particles list, which might change.
        """
        self.particles = particles
    

    def create_matrix_rel_to_self(self, vector_force_range: float | int, ) -> tuple[tuple[int, float], ...]: # tuple[int, float] for however long self.particles is
        """
        Docstring for create_matrix_rel_to_self
        
        :param self: Description
        :return: Description
        :rtype: tuple[tuple[int, float]]

        the reutrned tuple contains:
        - tuples for each index into self.particles
        inside each tuple contains:
        - the index of the interacting particle in self.particles
        - a force which will be applied
        """

        final_matrix = [
        (i, choice([1, -1]) * random() * vector_force_range)
        for i in range(len(self.particles))
        ]
        return final_matrix


    from math import sqrt

    def get_current_velocity(
        self_index: int,
        cur_position: tuple[int, int],
        cur_velocity: tuple[float, float, float],
        self_area_of_effect: int,
        self_matrix: tuple[tuple[int, float], ...],
        particle_infos: list[tuple[tuple[int, int], float, int | None, tuple[tuple[int, float], ...]]]
    ) -> tuple[float, float, float]:
        """
        Docstring for get_current_velocity
        
        :param self_index: Description
        :type self_index: int
        :param cur_position: Description
        :type cur_position: tuple[int, int]
        :param cur_velocity: Description
        :type cur_velocity: tuple[float, float, float]
        :param self_area_of_effect: Description
        :type self_area_of_effect: int
        :param self_matrix: Description
        :type self_matrix: tuple[tuple[int, float], ...]
        :param particle_infos: Description
        :type particle_infos: list[tuple[tuple[int, int], float, int | None, tuple[tuple[int, float], ...]]]
        :return: Description
        :rtype: tuple[float, float, float]

        this gets the current velocity.

        I do not know how

        !!!!!!!!! NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE !!!!!!!!!
        this funciton was generated by chatGPT because I do not know vector math
        forgive me for this grave sin
        """
        cx, cy = cur_position
        total_fx = 0.0
        total_fy = 0.0

        for i, (pos, other_force, other_aoe, other_matrix) in enumerate(particle_infos):
            if i == self_index:
                continue

            ox, oy = int(round(pos[0])), int(round(pos[1]))
            dx = ox - cx
            dy = oy - cy
            dist_sq = dx*dx + dy*dy
            if dist_sq == 0:
                continue

            dist = sqrt(dist_sq)
            nx = dx / dist
            ny = dy / dist

            # --- OTHER → SELF ---
            radius = other_aoe if other_aoe is not None else 10
            if dist_sq <= radius * radius:
                # add other particle's default force
                total_fx += nx * other_force
                total_fy += ny * other_force
                # add force from other particle's self_matrix toward self
                other_force_matrix = next((f for idx, f in other_matrix if idx == self_index), 0)
                total_fx += nx * other_force_matrix
                total_fy += ny * other_force_matrix

            # --- SELF → OTHER ---
            if dist_sq <= self_area_of_effect * self_area_of_effect:
                self_force = next((f for idx, f in self_matrix if idx == i), 0)
                total_fx -= nx * self_force
                total_fy -= ny * self_force

        # Apply current velocity
        speed, dirX, dirY = cur_velocity
        dirX += total_fx
        dirY += total_fy
        new_speed = sqrt(dirX**2 + dirY**2)
        if new_speed != 0:
            dirX /= new_speed
            dirY /= new_speed

        return new_speed, dirX, dirY
    
    


                    
















